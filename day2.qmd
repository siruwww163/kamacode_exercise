---
title: "算法训练营Day 2"
author: "Siru Wu"
date: today
format: 
  html:
    embed-resources: true
---

今天是算法训练营的第二天。激动！

## [209 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)

> 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。
> 
> 示例：
> 
> - 输入：s = 7, nums = [2,3,1,2,4,3]
> - 输出：2
> - 解释：子数组 [4,3] 是该条件下的长度最小的子数组。
> - 提示：
> - 1 <= target <= 10^9
> - 1 <= nums.length <= 10^5
> - 1 <= nums[i] <= 10^5

在看视频讲解之前只想到了暴力解法（甚至还是双指针版本的但是做出来效果跟暴力解法一模一样的那种。。。），看了视频讲解才发现原来还有固定终止位置，然后移动起始位置，不断地缩小起始位置和终止位置的区间来判断是否有更小的区间能满足题目的要求。for 循环里面的j表示的是终止位置。

滑动窗口 - 双指针法
```{python}
class Solution:
    def minSubArrayLen(self, target:int, nums:List[int]) -> int:
        len_nums = len(nums)
        left = 0
        right = 0
        # 这里不能用min_len = 0代替，这样的话min_len的值就被固定成了0，不管再短的子数组长度都不会短于0
        min_len = float('inf') # 这里用∞作为初始值，表示“还没找到任何合法子数组”。
        cum_sum = 0

        while right < len_nums: # 这里也可以写成 for right in range(len_nums) 或者right <= len_nums-1
            cum_sum += nums[right]

            while cum_sum >= target:
                min_len = min(min_len, right - left + 1)
                cum_sum -= nums[left]
                left += 1
            
            right += 1
        return min_len if min_len != float('inf') else 0
```

暴力法
```{python}
class Solution:
    def minSubArrayLen(self, target:int, nums:List[int]) -> int:
        len_num = len(nums)
        min_len = float('inf')

        for i in range(len_num):
            cum_sum = 0
            for j in range(i, len_num): # 这里的j是从i开始的，不是1
                cum_sum += nums[j]
                if cum_sum >= target:
                    min_len = min(min_len, j-i+1)
                    break
         return min_len if min_len != float('inf') else 0
```

## [59.螺旋矩阵II](https://leetcode.cn/problems/spiral-matrix-ii/description/)

> 给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。
> 
> 示例: 输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]

```{python}
# 这道题的思路就是先创一个全部为0的matrix，然后创建x,y轴的起始点，确定loop和中心点。然后开始建四条边，再填充。最后填充中心点matrix[mid][mid]。
class Solution(object):
    def generateMatrix(self, n):
        """
        :type n: int
        :rtype: List[List[int]]
        """
        matrix = [[0] * n for _ in range(n)] # 创建一个全部值为0的matrix
        layer_count = n//2
        num = 1

        # 创建四条边
        for layer in range(layer_count):
            top = layer
            bottom = n - 1 - layer
            left = layer
            right = n - 1 - layer

            # 填充上边，matrix[top][j]
            for j in range(left, right): # 这里不能用range(n), 不然的话填到内圈的时候会重复填外圈的东西
                matrix[top][j] = num
                num += 1

            # 填充右边 matrix[i][right]
            for i in range(top, bottom):
                matrix[i][right] = num
                num += 1

            # 填充下边 matrix[bottom][j]
            for j in range(right, left, -1):
                matrix[bottom][j] = num
                num += 1

            # 填充左边 matrix[i][left]
            for i in range(bottom, top, -1):
                matrix[i][left] = num
                num += 1

        # 如果n是基数，那么这个matrix是有一个中心点matrix[mid][mid]， 值为n*n，也就是累计的num
        if n % 2 == 1:
            mid = n // 2
            matrix[mid][mid] = num # 这里也可以写成n*n

        return matrix
```