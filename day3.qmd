---
title: "算法训练营Day 3"
author: "Siru Wu"
date: today
format: 
  html:
    embed-resources: true
---

今天是算法训练营的第三天。今天要学习关于链表的知识。先是看了[链表理论基础](https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B),说实话看文字讲解和图表看不懂，但是看到python code就那么两行的时候似乎又看懂了。希望通过今天的刷题能掌握关于链表的知识。

## [203 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/description/)

> 给你一个链表的头节点 head 和一个整数 val，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。
>
> 示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]
> ![](image\203-example1.png){width=50%}
> 
> 示例 2： 输入：head = [], val = 1 输出：[]
> 
> 示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]

这道理有两个解法：虚拟头解法 和 原链表删除法

### 虚拟头解法
```{python}
class Solution:
    def removeElements(self, head:Optional[ListNode], val:int) -> Optional[ListNode]:
        # 初始化
        dummy = Listnode(0) # dummy 永远不动
        dummy.next = head
        current = dummy # current 负责检查它后面的节点, 并且current必须指向dummy

        while current.next: # while current.next是在检查current之后是否还有val，这个链表是否结束
            if current.next.val == val: # 这个地方记得用 ==，而不是=
                current.next = current.next.next # 如果发现有val值，用next.next的值来覆盖next的值
            else:
                current = current.next

        # 在链表里，next 不是下一个数字，而是 指向下一个节点的指针，而每个节点又继续指向下一个节点，所以从一个节点开始，就能读到整条链表
        return dummy.next # 这个地方不能直接return current, 因为current是一个val值，而不是一个链表
```


### 原链表删除法

```{python}
class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        # 删谁，就用谁做 while 条件，检查 head，就只判断 head，别用 head.next 来控制 head
        # while head and head.next:
        #     if head.val == val:
        #         head = head.next
        # 删除头节点
        while head and head.val == val:
            head = head.next

        # 删除中间节点
        current = head
        while current and current.next: # 这个地方要加current是因为 current 本身有可能是 None，而我们不能在 None 上访问 .next
            if current.next.val == val:
                current.next = current.next.next
            else:
                current = current.next
        
        return head
```

## [707 设计链表](https://leetcode.cn/problems/design-linked-list/)

> 你可以选择使用单链表或者双链表，设计并实现自己的链表。
> 
> 单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。
> 
> 如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。
> 在链表类中实现这些功能：
> 
> - get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
> - addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
> - addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
> - addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
> - deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

### 单链表

> 这份代码一共分三层：
> 
> - ListNode: 定义节点长什么样
> 
> - MyLinkedList: 定义链表这个对象有什么属性
> 
> - 链表提供的 5 个操作: get / add / delete

```{python}
class ListNode():
    def __init__(self, val = 0, next = None): # 因为我们在新创一个链表，而不是在操作一个已经存在的链表，所以这里必须用_init_初始化创建链表对象
        self.val = val
        self.next = next

class MyLinkedList(object):

    def __init__(self):
        # 这里的这两行是 数据结构层面的长期 dummy
        self.dummy = ListNode()
        self.size = 0

        # LeetCode 203的版本是 算法函数里的临时 dummy
        # dummy = ListNode(0)
        # dummy.next = head
        # cur = dummy
        
    # 获取链表中第 index 个节点的值。如果索引无效，则返回-1。
    def get(self, index):
        """
        :type index: int
        :rtype: int
        """
        if index < 0 or index >= self.size: # 这里必须用 >= ， index = self.size是非法的
            return -1

        current = self.dummy.next
        for i in range(index):
            current = current.next
        return current.val

    # 在链表的第一个元素之前添加一个值为 val 的节点
    def addAtHead(self, val):
        """
        :type val: int
        :rtype: None
        """
        self.dummy.next = ListNode(val, self.dummy.next)
        # 这一句拆开写的话就是
        # new_node = ListNode(val, self.dummy.next)
        # self.dummy.next = new_node

        self.size += 1 # 链表里多了一个节点，长度加 1，get 要用，index 判断要用
        
    # 将值为 val 的节点追加到链表的最后一个元素
    def addAtTail(self, val):
        """
        :type val: int
        :rtype: None
        """
        current = self.dummy # 这里不能用self.dummy.next，addAtTail要考虑空列表的情况
        while current.next:
            current = current.next
        current.next = ListNode(val)
        self.size  += 1
        
    # 在链表中的第 index 个节点之前添加值为 val  的节点
    def addAtIndex(self, index, val):
        """
        :type index: int
        :type val: int
        :rtype: None
        """
        # 先判断会不会越界
        if index < 0 or index > self.size: 
            # 这里不用>=是因为index = self.size的时候就是尾插的情况
            return 

        current = self.dummy
        for i in range(index):
            current = current.next

        current.next = ListNode(val, current.next) 
        # 这里不用current而是用current.next是因为要替换current.next(新加的值)而不是替换current本身的值。
        # 把这一句拆开等价于
        # new_node = ListNode(val)
        # new_node.next = current.next
        # current.next = new_node

        self.size += 1

    # 如果索引 index 有效，则删除链表中的第 index 个节点。
    def deleteAtIndex(self, index):
        """
        :type index: int
        :rtype: None
        """
        if index < 0 or index >= self.size:
            return # 这里不能return -1, return ≈ stop（结束函数）

        current = self.dummy
        for i in range(index):
            current = current.next # 这一句只负责移动current，不要在for里面删除节点
        current.next = current.next.next
        self.size -= 1



# Your MyLinkedList object will be instantiated and called as such:
# obj = MyLinkedList()
# param_1 = obj.get(index)
# obj.addAtHead(val)
# obj.addAtTail(val)
# obj.addAtIndex(index,val)
# obj.deleteAtIndex(index)
```

### 双链表

```{python}
class MyLinkedList(object):

    def __init__(self):
        

    def get(self, index):
        """
        :type index: int
        :rtype: int
        """
        

    def addAtHead(self, val):
        """
        :type val: int
        :rtype: None
        """
        

    def addAtTail(self, val):
        """
        :type val: int
        :rtype: None
        """
        

    def addAtIndex(self, index, val):
        """
        :type index: int
        :type val: int
        :rtype: None
        """
        

    def deleteAtIndex(self, index):
        """
        :type index: int
        :rtype: None
        """
        


# Your MyLinkedList object will be instantiated and called as such:
# obj = MyLinkedList()
# param_1 = obj.get(index)
# obj.addAtHead(val)
# obj.addAtTail(val)
# obj.addAtIndex(index,val)
# obj.deleteAtIndex(index)
```

## [反转链表](https://leetcode.cn/problems/reverse-linked-list/description/)

> 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
>
> ![](image\206-example1.png)
>
> ![](image\206-example2.png)