---
title: "算法训练营Day 22"
author: "Siru Wu"
date: today
format: 
  html:
    embed-resources: true
---

[回溯算法理论基础](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)

回溯算法模板框架如下：

```{python}
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

## [77. 组合](https://leetcode.cn/problems/combinations/description/)

> 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。
> 
> 你可以按 任何顺序 返回答案。
>
> ![](/image/77example.png){width=50%}

```{python}
class Solution:
    def backtracking(self, n, k, startindex, path, result):
        if len(path) == k:
            result.append(path[:])
            return

        for i in range(startindex, n + 1):
            path.append(i)
            self.backtracking(n, k, i + 1, path, result)
            path.pop()

    def combine(self, n: int, k: int) -> List[List[int]]:
        result = []
        self.backtracking(n, k, 1, [], result)
        return result
```

## [216.组合总和III](https://leetcode.cn/problems/combination-sum-iii/description/)

> 找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：
> 
> - 只使用数字1到9
> 
> - 每个数字 最多使用一次 
> 
> 返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。
>
> ![](/image/216example.png){width=50%}

```{python}
class Solution:
    def backtracking(self, targetSum, k, curSum, startIndex, path, result):
        if curSum > targetSum:
            return

        if len(path) == k:
            if curSum == targetSum:
                result.append(path[:])
            return

        for i in range(startIndex, 9 - (k - len(path)) + 2):
            curSum += i
            path.append(i)
            self.backtracking(targetSum, k, curSum, i + 1, path, result)
            curSum -= i
            path.pop()

    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        result = []
        self.backtracking(n, k, 0, 1, [], result)
        return result
```


## [17.电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/)

> 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。
> 
> 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
>
> ![](/image/17_phone_number.png)
>
> ![](/image/17example1.png){width=50%}

```{python}
class Solution:
    def __init__(self):
        self.letterMap = [
            "",     # 0
            "",     # 1
            "abc",  # 2
            "def",  # 3
            "ghi",  # 4
            "jkl",  # 5
            "mno",  # 6
            "pqrs", # 7
            "tuv",  # 8
            "wxyz"  # 9
        ]
        self.result = []
        self.s = ""

    def backtracking(self, digits, index): # 这里index指的是digits的第几位
        # self.s是用来存当前未完成的结果，就是每个字母可以和谁配
        # self.result是用来存已经搜索好的结果
        if index == len(digits):
            self.result.append(self.s)
            return

        digit = int(digits[index]) # 找digits里面每一个index对应的是哪个val
        letters = self.letterMap[digit] # 找这个val对应的letters

        for i in range(len(letters)):
            self.s += letters[i]
            self.backtracking(digits, index + 1)
            self.s = self.s[:-1]

    def letterCombinations(self, digits: str) -> List[str]:
        if len(digits)  == 0:
            return self.result

        self.backtracking(digits, 0)
        return self.result
```