---
title: "算法训练营Day 16"
author: "Siru Wu"
date: today
format: 
  html:
    embed-resources: true
---

## [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/description/)

> 给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。
> 
> 假设二叉树中至少有一个节点。
>
> ![](/image/513example.png){width=50%}

### 递归法

```{python}
class Solution:
    def findBottomLeftValue(self, root: Treenode) -> int:
        self.max_depth = float('-inf') # 这个地方要用 负的 inf，如果用正的inf那么max_depth永远不会更新

        # 这一句的意思是：现在还没有任何答案，等 DFS 过程中再决定，它是一个占位状态
        self.result = None # 这里result要写成None而不是0， 0表示已经有值了，但是None表示还没赋值

        self.traversal(root, 0) # 这个要写在self.result = None的后面，如果写在它前面，那么一调用traversal result又会更新成None

        return self.result

    def traversal(self, node, depth):
        if not node.left and not node.right:
            if depth > self.max_depth:
                self.max_depth = depth
                self.result = node.val
            return

        # 在递归里面这里只能用if 不能用while， 因为递归就是在自动往下跑，如果用while就是在同一层不停地跑
        if node.left:
            # 这一行是精简版
            # 精简版实际没有跑到下一层，它只是在当前层计算了下一层的值然后传回来
            self.traversal(node.left, depth+1)

            # 这是第二种写法
            # depth += 1
            # self.traversal(node.left, depth)
            # depth -= 1

        if node.right:
            depth += 1
            self.traversal(node.right, depth)
            depth -= 1
            # self.traversal(node.right, depth+1)
```

### 迭代法

```{python}
from collections import deque

class Solution:
    def findBottomLeftValue(self, root: TreeNode) -> int:
        if root is None:
            return 0

        queue = deque([root])
        result = 0
        while queue:
            size = len(queue)
            for i in range(size): # 这里不能直接写 range(len(queue))，因为queue 在 for 循环内部一直在变，popleft() 会减少长度，append() 会增加长度，所以我们要先 先固定当前层大小
                node = queue.popleft()

                if i == 0: # 在 BFS 中，同一层节点入队顺序是：左 → 右，所以 i == 0 一定是这一层的最左节点
                    result = node.val
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

        return result
```

## [112. 路径总和](https://leetcode.cn/problems/path-sum/description/)

> 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。
> 
> 叶子节点 是指没有子节点的节点。
>
> ![](/image/112example1.png){width=50%}
>
> ![](/image/112example2.png){width=50%}

### 递归法

```{python}
class Solution:
    def traversal(self, cur: TreeNode, count: int) -> bool:
        if not cur.left and not cur.right and count == 0:
            return True
        if not cur.left and not cur.right:
            return False

        if cur.left:
            count -= cur.left.val
            if self.traversal(cur.left, count):
                return True
            count += cur.left.val

        if cur.right:
            count -= cur.right.val
            if self.traversal(cur.right, count):
                return True
            count += cur.right.val

        return False

    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return False
        return self.traversal(root, targetSum - root.val)

```

### 递归法，精简版

```{python}
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return False
        if not root.left and not root.right and targetSum == root.val:
            return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)
```

### 迭代法

```{python}
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return False
        # 此时栈里要放的是pair<节点指针，路径数值>
        st = [(root, root.val)]
        while st:
            node, path_sum = st.pop()
            # 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true
            if not node.left and not node.right and path_sum == targetSum:
                return True
            # 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if node.right:
                st.append((node.right, path_sum + node.right.val))
            # 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if node.left:
                st.append((node.left, path_sum + node.left.val))
        return False

```

## [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/description/)

> 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。
> 
> 叶子节点 是指没有子节点的节点。
>
> ![](/image/113example1.png){width=50%}
>
> ![](/image/113example2.png){width=50%}

```{python}
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init__(self):
        self.result = []
        self.path = []

    def traversal(self, cur, count):
        if not cur.left and not cur.right and count == 0: # 遇到了叶子节点且找到了和为sum的路径
            self.result.append(self.path[:])
            return

        if not cur.left and not cur.right: # 遇到叶子节点而没有找到合适的边，直接返回
            return

        if cur.left: # 左 （空节点不遍历）
            self.path.append(cur.left.val)
            count -= cur.left.val
            self.traversal(cur.left, count) # 递归
            count += cur.left.val # 回溯
            self.path.pop() # 回溯

        if cur.right: #  右 （空节点不遍历）
            self.path.append(cur.right.val) 
            count -= cur.right.val
            self.traversal(cur.right, count) # 递归
            count += cur.right.val # 回溯
            self.path.pop() # 回溯

        return

    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        self.result.clear()
        self.path.clear()
        if not root:
            return self.result
        self.path.append(root.val) # 把根节点放进路径
        self.traversal(root, targetSum - root.val)
        return self.result 
```

### 迭代法

```{python}
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        if not root:
            return [] # 这里return要return []，而不是None

        stack = [(root, [root.val])] # 注意这里root.val要加[], 它是list不是int
        res = []

        while stack:
            node, path = st.pop()
            if not node.left and not node.rigth and sum(path) == targetSum:
                res.append(path)

            if node.right:
                stack.append((node.right, path + [node.right.val]))
            if node.left:
                stack.append((node.left, path + [node.left.val]))
        return res
```

## [106.从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)

> 给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。
>
> ![](/image/116example.png){width=50%}

1. 递归出口  
   如果 postorder 为空，说明当前子树没有节点，直接返回 None。

2. 确定根节点  
   后序遍历的最后一个元素是当前子树的根，取  
   root_val = postorder[-1]，并创建 root = TreeNode(root_val)。

3. 在中序中定位根  
   在 inorder 中找到根的位置  
   separator_idx = inorder.index(root_val)，  
   这个位置把中序数组分成左子树和右子树两部分。

4. 切分中序数组  
   左子树的中序为 inorder[:separator_idx]  
   右子树的中序为 inorder[separator_idx + 1:]

5. 按左子树大小切分后序数组  
   左子树节点数等于 len(inorder_left)，  
   后序遍历结构是 [左子树 | 右子树 | 根]，因此  
   左子树后序为 postorder[:len(inorder_left)]  
   右子树后序为 postorder[len(inorder_left) : len(postorder) - 1]

6. 递归构建左右子树  
   root.left = buildTree(inorder_left, postorder_left)  
   root.right = buildTree(inorder_right, postorder_right)

7. 返回当前子树的根节点  
   返回 root，交给上一层递归继续拼接整棵树。


```{python}
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        # 第一步: 特殊情况讨论: 树为空. (递归终止条件)
        if not postorder:
            return None

        # 第二步: 后序遍历的最后一个就是当前的中间节点.
        root_val = postorder[-1]
        root = TreeNode(root_val) # 这里要用 () 而不是 [], TreeNode 是一个类，创建节点要用 圆括号 调构造函数

        # 第三步: 找切割点.
        seperator_idx = inorder.index(root_val)

        # 第四步: 切割inorder数组. 得到inorder数组的左,右半边.
        inorder_left = inorder[:seperator_idx]
        inorder_right = inorder[seperator_idx + 1:]

        # 第五步: 切割postorder数组. 得到postorder数组的左,右半边.
        postorder_left = postorder[:len(inorder_left)]
        postorder_right = postorder[len(inorder_left):len(postorder) - 1]

        # 第六步: 递归
        root.left = self.buildTree(inorder_left, postorder_left)
        root.right = self.buildTree(inorder_right, postorder_right)

        return root
```

## [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

> 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。
>
> ![](/image/105example.png){width=50%}

```{python}
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if not preorder:
            return None

        root_val = preorder[0]
        root = TreeNode(root_val)

        seperator_idx = inorder.index(root_val)

        inorder_left = inorder[:seperator_idx]
        inorder_right = inorder[seperator_idx + 1:]

        preorder_left = preorder[1:1 + len(inorder_left)]
        preorder_right = preorder[1 + len(inorder_left):]

        root.left = self.buildTree(preorder_left, inorder_left)
        root.right = self.buildTree(preorder_right, inorder_right)

        return root
```