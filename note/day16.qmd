---
title: "算法训练营Day 16"
author: "Siru Wu"
date: today
format: 
  html:
    embed-resources: true
---

## [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/description/)

> 给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。
> 
> 假设二叉树中至少有一个节点。
>
> ![](/image/513example.png){width=50%}

### 递归法

```{python}
class Solution:
    def findBottomLeftValue(self, root: Treenode) -> int:
        self.max_depth = float('-inf') # 这个地方要用 负的 inf，如果用正的inf那么max_depth永远不会更新

        # 这一句的意思是：现在还没有任何答案，等 DFS 过程中再决定，它是一个占位状态
        self.result = None # 这里result要写成None而不是0， 0表示已经有值了，但是None表示还没赋值

        self.traversal(root, 0) # 这个要写在self.result = None的后面，如果写在它前面，那么一调用traversal result又会更新成None

        return self.result

    def traversal(self, node, depth):
        if not node.left and not node.right:
            if depth > self.max_depth:
                self.max_depth = depth
                self.result = node.val
            return

        # 在递归里面这里只能用if 不能用while， 因为递归就是在自动往下跑，如果用while就是在同一层不停地跑
        if node.left:
            # 这一行是精简版
            # 精简版实际没有跑到下一层，它只是在当前层计算了下一层的值然后传回来
            self.traversal(node.left, depth+1)

            # 这是第二种写法
            # depth += 1
            # self.traversal(node.left, depth)
            # depth -= 1

        if node.right:
            depth += 1
            self.traversal(node.right, depth)
            depth -= 1
            # self.traversal(node.right, depth+1)
```

### 迭代法

```{python}
from collections import deque

class Solution:
    def findBottomLeftValue(self, root: TreeNode) -> int:
        if root is None:
            return 0

        queue = deque([root])
        result = 0
        while queue:
            size = len(queue)
            for i in range(size): # 这里不能直接写 range(len(queue))，因为queue 在 for 循环内部一直在变，popleft() 会减少长度，append() 会增加长度，所以我们要先 先固定当前层大小
                node = queue.popleft()

                if i == 0: # 在 BFS 中，同一层节点入队顺序是：左 → 右，所以 i == 0 一定是这一层的最左节点
                    result = node.val
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

        return result
```

## [112. 路径总和](https://leetcode.cn/problems/path-sum/description/)

> 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。
> 
> 叶子节点 是指没有子节点的节点。
>
> ![](/image/112example1.png){width=50%}
>
> ![](/image/112example2.png){width=50%}

### 递归法

```{python}
class Solution:
    def traversal(self, cur: TreeNode, count: int) -> bool:
        if not cur.left and not cur.right and count == 0:
            return True
        if not cur.left and not cur.right:
            return False

        if cur.left:
            count -= cur.left.val
            if self.traversal(cur.left, count):
                return True
            count += cur.left.val

        if cur.right:
            count -= cur.right.val
            if self.traversal(cur.right, count):
                return True
            count += cur.right.val

        return False

    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return False
        return self.traversal(root, targetSum - root.val)

```

### 递归法，精简版

```{python}
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return False
        if not root.left and not root.right and targetSum == root.val:
            return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)
```

### 迭代法

```{python}
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return False
        # 此时栈里要放的是pair<节点指针，路径数值>
        st = [(root, root.val)]
        while st:
            node, path_sum = st.pop()
            # 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true
            if not node.left and not node.right and path_sum == targetSum:
                return True
            # 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if node.right:
                st.append((node.right, path_sum + node.right.val))
            # 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if node.left:
                st.append((node.left, path_sum + node.left.val))
        return False

```

## [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/description/)

> 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。
> 
> 叶子节点 是指没有子节点的节点。
>
> ![](/image/113example1.png){width=50%}
>
> ![](/image/113example2.png){width=50%}

```{python}
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init__(self):
        self.result = []
        self.path = []

    def traversal(self, cur, count):
        if not cur.left and not cur.right and count == 0: # 遇到了叶子节点且找到了和为sum的路径
            self.result.append(self.path[:])
            return

        if not cur.left and not cur.right: # 遇到叶子节点而没有找到合适的边，直接返回
            return

        if cur.left: # 左 （空节点不遍历）
            self.path.append(cur.left.val)
            count -= cur.left.val
            self.traversal(cur.left, count) # 递归
            count += cur.left.val # 回溯
            self.path.pop() # 回溯

        if cur.right: #  右 （空节点不遍历）
            self.path.append(cur.right.val) 
            count -= cur.right.val
            self.traversal(cur.right, count) # 递归
            count += cur.right.val # 回溯
            self.path.pop() # 回溯

        return

    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        self.result.clear()
        self.path.clear()
        if not root:
            return self.result
        self.path.append(root.val) # 把根节点放进路径
        self.traversal(root, targetSum - root.val)
        return self.result 
```

### 迭代法

```{python}


```