---
title: "算法训练营Day 34"
author: "Siru Wu"
date: today
format: 
  html:
    embed-resources: true
---

## [62.不同路径](https://leetcode.cn/problems/unique-paths/description/)

> 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
> 
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
> 
> 问总共有多少条不同的路径？
>
> ![](/image/62example.png){width=50%}

### 递归法（超时）

```{python}
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        if m == 1 and n == 1:
            return 1

        return self.uniquePaths(m - 1, n) + self.uniquePaths(m, n - 1)
```

### 动态规划（版本一）

```{python}
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 外层 range(m) → 创建 m 行
        # 内层 [0] * n → 每一行有 n 列
        dp = [[0] * n for _ in range(m)]  

        for i in range(m): # m控制行
            dp[i][0] = 1
        for j in range(n):
            dp[0][j] = 1

        for i in range(1, m): # 这个地方的起始点是1不是0, 我们已经定义了dp[0][j]和dp[i][0]
            for j in range(1, n):
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        return dp[m - 1][n - 1] # 终点格子的坐标是 (m - 1), (n - 1)
```

## [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/description/)

> 给定一个 m x n 的整数数组 grid。一个机器人初始位于 左上角（即 grid[0][0]）。机器人尝试移动到 右下角（即 grid[m - 1][n - 1]）。机器人每次只能向下或者向右移动一步。
> 
> 网格中的障碍物和空位置分别用 1 和 0 来表示。机器人的移动路径中不能包含 任何 有障碍物的方格。
> 
> 返回机器人能够到达右下角的不同路径数量。
> 
> 测试用例保证答案小于等于 2 * 109。
>
> ![](/image/63example1.png){width=50%}
>
> ![](/image/63example2.png){width=50%}

```{python}

```

## [96.不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/description/)

> 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
>
> ![](/image/96example.png){width=50%}

```{python}

```
