---
title: "算法训练营Day 34"
author: "Siru Wu"
date: today
format: 
  html:
    embed-resources: true
---

## [62.不同路径](https://leetcode.cn/problems/unique-paths/description/)

> 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
> 
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
> 
> 问总共有多少条不同的路径？
>
> ![](/image/62example.png){width=50%}

### 递归法（超时）

```{python}
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        if m == 1 and n == 1:
            return 1

        return self.uniquePaths(m - 1, n) + self.uniquePaths(m, n - 1)
```

### 动态规划（版本一）

```{python}
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 外层 range(m) → 创建 m 行
        # 内层 [0] * n → 每一行有 n 列
        dp = [[0] * n for _ in range(m)]  

        for i in range(m): # m控制行
            dp[i][0] = 1
        for j in range(n):
            dp[0][j] = 1

        for i in range(1, m): # 这个地方的起始点是1不是0, 我们已经定义了dp[0][j]和dp[i][0]
            for j in range(1, n):
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] # 题目规定了机器人只能往下或者往右走，所以它的上一步一定是左边或者上面
        return dp[m - 1][n - 1] # 终点格子的坐标是 (m - 1), (n - 1)
```

## [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/description/)

> 给定一个 m x n 的整数数组 grid。一个机器人初始位于 左上角（即 grid[0][0]）。机器人尝试移动到 右下角（即 grid[m - 1][n - 1]）。机器人每次只能向下或者向右移动一步。
> 
> 网格中的障碍物和空位置分别用 1 和 0 来表示。机器人的移动路径中不能包含 任何 有障碍物的方格。
> 
> 返回机器人能够到达右下角的不同路径数量。
> 
> 测试用例保证答案小于等于 2 * 109。
>
> ![](/image/63example1.png){width=50%}
>
> ![](/image/63example2.png){width=50%}

```{python}
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        # 获取网格的行数和列数
        m = len(obstacleGrid)      # 行数
        n = len(obstacleGrid[0])   # 列数

        # 如果起点或终点是障碍物，直接返回0（无法到达）
        if obstacleGrid[m - 1][n - 1] == 1 or obstacleGrid[0][0] == 1:
            return 0

        # 创建dp数组
        # dp[i][j] 表示从 (0,0) 走到 (i,j) 的不同路径数量
        dp = [[0] * n for _ in range(m)]

        # 初始化第一列
        # 第一列只能从上往下走
        # 一旦遇到障碍物，后面的格子都不可达
        for i in range(m):
            if obstacleGrid[i][0] == 0:
                dp[i][0] = 1
            else:
                break  # 遇到障碍物，后面全部为0，直接退出

        # 初始化第一行
        # 第一行只能从左往右走
        # 一旦遇到障碍物，后面的格子都不可达
        for j in range(n):
            if obstacleGrid[0][j] == 0:
                dp[0][j] = 1
            else:
                break  # 遇到障碍物，后面全部为0

        # 开始状态转移
        # 从 (1,1) 开始遍历，因为第一行第一列已经初始化过
        for i in range(1, m):
            for j in range(1, n):
                # 如果当前格子是障碍物，则无法到达，保持0
                if obstacleGrid[i][j] == 1:
                    continue

                # 如果不是障碍物
                # 当前路径数 = 上面路径数 + 左边路径数
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]

        # 返回右下角的路径数量
        return dp[m - 1][n - 1]
```

## [96.不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/description/)

> 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
>
> ![](/image/96example.png){width=50%}

```{python}

```
