---
title: "算法训练营Day 23"
author: "Siru Wu"
date: today
format: 
  html:
    embed-resources: true
---

## [39. 组合总和](https://leetcode.cn/problems/combination-sum/description/)

> 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。
> 
> candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 
> 
> 对于给定的输入，保证和为 target 的不同组合数少于 150 个。
>
> ![](/image/39example.png){width=50%}

```{python}
class Solution:
    def backtracking(self, candidates, curSum, target, startIndex, path, result):
        if curSum == target:
            result.append(path[:])
            return result
        if curSum > target:
            return

        for i in range(startIndex, len(candidates)):
            curSum += candidates[i]
            path.append(candidates[i])
            self.backtracking(candidates, curSum, target, i, path, result)
            curSum -= candidates[i]
            path.pop()

    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        result = []
        self.backtracking(candidates, 0, target, 0, [], result)
        return result
```

## [40.组合总和II](https://leetcode.cn/problems/combination-sum-ii/description/)

> 给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
> 
> candidates 中的每个数字在每个组合中只能使用 一次 。
> 
> 注意：解集不能包含重复的组合。 
>
> ![](/image/40example.png){width=50%}

```{python}
class Solution:
    def backtracking(self, candidates, target, curSum, startIndex, path, result):
        if curSum > target:
            return
        if curSum == target:
            result.append(path[:])
            return result
        
        for i in range(startIndex, len(candidates)):
            if i > startIndex and candidates[i] == candidates[i - 1]:
                continue # 如果有连续的两个val相同，跳过第二个相同值

            if curSum + candidates[i] > target:
                break

            curSum += candidates[i]
            path.append(candidates[i])
            self.backtracking(candidates, target, curSum, i + 1, path, result)
            curSum -= candidates[i]
            path.pop()

    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        result = []
        candidates.sort()
        self.backtracking(candidates, target, 0, 0, [], result)
        return result
```

## [131.分割回文串](https://leetcode.cn/problems/palindrome-partitioning/description/)

> 给你一个字符串 s，请你将 s 分割成一些 子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。
>
> **示例 1：**
> 
> - 输入：s = "aab"
> 
> - 输出：[["a","a","b"],["aa","b"]]
> 
> **示例 2：**
> 
> - 输入：s = "a"
> 
> - 输出：[["a"]]

```{python}


```