---
title: "算法训练营Day 6"
author: "Siru Wu"
date: today
format: 
  html:
    embed-resources: true
---

今天是第三章 **哈希表**

![](/image/set_map_comparison.png)

## [242 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/description/)

> 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
> 
> 示例 1: 输入: s = "anagram", t = "nagaram" 输出: true
> 
> 示例 2: 输入: s = "rat", t = "car" 输出: false
> 
> 说明: **你可以假设字符串只包含小写字母**

### Python写法1：ASCII

```{python}
class Solution:
    def isAnagram(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: bool
        """
        record = [0] * 26 # a-z有26个字母
        for i in s:
            record[ord(i) - ord('a')] += 1 # 这里题目保证了input只有 a-z 的字母输入, 才可以这样写

        for i in t:
            record[ord(i) - ord('a')] -= 1 # 如果有的字母s里面没有但是t里面有，那那个index对应的值就不为0，那么后面就可以用 if record[i] != 0 来检查是否有不一样的值

        for i in range(26):
            if record[i] != 0:
                return False
            
        return True # 这一句跟上面的for并排是因为要检查完26个index发现没有false之后才返回true
```

### Python 写法2：Counter

```{python}
from collections import Counter

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        a_count = Counter(s)
        b_count = Counter(t)

        return a_count == b_count
```

## [349 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/description/)

> 给定两个数组 nums1 和 nums2 ，返回 它们的 交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。
>
> ![](/image/349_example1.png)

- **set 用 add**
- **list 用 append**

### 版本1：字典和集合

```{python}
# 题目里面说元素唯一，set的一个特性就是 不允许重复key
# set：只存 key
# map：存 key + value

class Solution(object):
    def intersection(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        table = {}
        for num in nums1:
            table[num] = table.get(num, 0) + 1 # 这里table.get要用圆括号() 而不是[]

        # 这是第二种写法

        # table = set(nums1)
        # res = set()

        # for num in nums2:
            # if num in table:
            #     res.add(num)
            #     table.remove(num)
        # return list(res)

        res = set()
        for num in nums2:
            if num in table:
                res.add(num) # set 用 add
                del table[num]

        return list(res) # 这个地方必须用list转成List，不然res输出是个set
```

### 版本2：集合

```{python}
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        return list(set(nums1) & set(nums2))
```


### 版本3：数组

```{python}
# 本题后面 力扣改了 题目描述 和 后台测试数据，增添了 数值范围：
# 1 <= nums1.length, nums2.length <= 1000
# 0 <= nums1[i], nums2[i] <= 1000
# 所以就可以 使用数组来做哈希表了， 因为数组都是 1000以内的

class Solution(object):
    def intersection(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        count1 = [0] * 1001
        count2 = [0] * 1001
        result = []

        for i in range(len(nums1)):
            count1[nums1[i]] += 1 # 这个地方没有在数每个数字出现了几次，而是把val转成index，只要这个数次出现了一次，就在这个对应的index上 += 1

        for j in range(len(nums2)):
            count2[nums2[j]] += 1

        for k in range(1001):
            if count1[k] * count2[k] > 0:
                result.append[k]

        return result
```

## [202 快乐数](https://leetcode.cn/problems/happy-number/description/)



## [两数之和](https://leetcode.cn/problems/two-sum/description/)

> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
> 
> 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。
> 
> 你可以按任意顺序返回答案。
>
> /![](/image/1_example.png)


### 暴力法

```{python}
class Solution(object):
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if nums[i] + nums[j] == target:
                    return [i, j]
```

### 使用字典，不使用enumerate

```{python}
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        record = {} # record是读一个i存一个数字，而不是一次性读完，所以最少要读到 i=1才能判断两数之和

        for i in range(len(nums)):
            if target - nums[i] in record:
                return [record[target - nums[i]], i]
            record[nums[i]] = i # 如果只读了 i = 0 的话现在record里面只有一个数字，没法做两数之和，所以要把读的数字存进record然后读下一个

        return []
```

### 使用字典，使用enumerate

```{python}
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        record = {}

        # enumerate 等价于：
        # index = 0
        # for value in nums:
            # 使用 index 和 value
            # index += 1

        # for index, value in enumerate(nums):这一行已经自动初始化并更新了 index 和 value, 所以这里我们不需要再手动初始化index, value
        for index, value in enumerate(nums):
            if target - value in record: # 遍历当前元素，并在map中寻找是否有匹配的key
                return [record[target - value], index]
            record[value] = index

        return []
```