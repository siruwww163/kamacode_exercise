---
title: "算法训练营Day 31"
author: "Siru Wu"
date: today
format: 
  html:
    embed-resources: true
---

## [56. 合并区间](https://leetcode.cn/problems/merge-intervals/description/)

> 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。
>
> **示例 1：**
> 
> - 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
> 
> - 输出：[[1,6],[8,10],[15,18]]
> 
> - 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
> 
> **示例 2：**
> 
> - 输入：intervals = [[1,4],[4,5]]
> 
> - 输出：[[1,5]]
> 
> - 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
> 
> **示例 3：**
> 
> - 输入：intervals = [[4,7],[1,4]]
> 
> - 输出：[[1,7]]
> 
> - 解释：区间 [1,4] 和 [4,7] 可被视为重叠区间。

```{python}
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
      result = []
      if not intervals:
        return result

      intervals.sort(key=lambda x:x[0])
      result.append(intervals[0]) # 因为intervals已经排序了，第一个区间直接放进去，因为没得比较
      for i in range(1, len(intervals)): # 这里的i就从 i = 1开始处理了，也就是我们要比i = 1的左边界 intervals[i][0] 和result里面已经有的区间的右边界 result[-1][1]
        if result[-1][1] >= intervals[i][0]:
          result[-1][1] = max(result[-1][1], intervals[i][1]) # 更新右边界
        else:
          result.append(intervals[i])
      return result
```

## [738.单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/description/)

> 当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。
> 
> 给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。
>
> **示例 1:**
> 
> - 输入: n = 10
> 
> - 输出: 9
> 
> **示例 2:**
> 
> - 输入: n = 1234
> 
> - 输出: 1234
> 
> **示例 3:**
> 
> - 输入: n = 332
> 
> - 输出: 299

### 暴力法（超时）

```{python}
class Solution:
    def checkNum(self, num):
      max_digit = 10 
      for i in range(num):
        digit = num % 10 # 找个位数的数字
        if max_digit > digit: # max_digit是最后一位的数字，如果这个数想单调递增那么后面一位的数字要大于前一位，所以要max_digit > digit
          max_digit = digit # 更新max_digit,后面就是倒数第二位的数字跟最后一位数字比较大小
        else:
          return False
        num // 10 # 移除已经比较过的末位数字，num//10之后开始比较新的末位数字（倒数第二位，倒数第三位...）
      return True

  def monotoneIncreasingDigits(self, N):
    for i in range(N, 0, -1): # range(start, stop, step) 从 start 开始, 每次走 step, 一直走到 到达 stop 之前停止,这里的意思就是 从N开始每次减 1，一直到大于 0 为止，不包含 0
      if self.checkNum(i):
        return i
    return 0
```

### 贪心

```{python}
class Solution:
    def monotoneIncreasingDigits(self, n: int) -> int:
        strNum = list(str(n)) # 先把数字变成字符串列表，因为字符串不能改某一位

        for i in range(len(strNum) - 1, 0, -1): # 从右往左遍历
            if strNum[i - 1] > strNum[i]: # 找到破坏递增的地方，左边数字 > 右边数字
                strNum[i - 1] = str(int(strNum[i - 1]) - 1) # 把左边减 1
                for j in range(i, len(strNum)): # 把i后面的数字全部变成9，因为我们想让结果尽可能大，例如把 ’322‘ -> '329'
                    strNum[j] = '9'

        return int(''.join(strNum))
```

## [968.监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/description/) (目前先跳过)

> 给定一个二叉树，我们在树的节点上安装摄像头。
> 
> 节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。
> 
> 计算监控树的所有节点所需的最小摄像头数量。
>
> ![](/image/968example1.png){width=50%}
>
> ![](/image/968example.png){width=50%}

```{python}

```