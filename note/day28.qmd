---
title: "算法训练营Day 28"
author: "Siru Wu"
date: today
format: 
  html:
    embed-resources: true
---

## [122.买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

> 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
> 
> 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。然而，你可以在 同一天 多次买卖该股票，但要确保你持有的股票不超过一股。
> 
> 返回 你能获得的 最大 利润 。
>
> ![](/image/122example.png){width=50%}

```{python}
# 局部最优：收集每天的正利润
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        result = 0
        for i in range(1, len(prices)):
            result += max(prices[i] - prices[i - 1], 0) # 如果是负利润，那么max(negative,0)就是0，相当于跳过负利润，只收集正利润
        return result
```

## [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/description/)

> 给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。
> 
> 判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。
>
> **示例 1：**
> 
> - 输入：nums = [2,3,1,1,4]
> 
> - 输出：true
> 
> - 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
> 
> **示例 2：**
> 
> - 输入：nums = [3,2,1,0,4]
> 
> - 输出：false
> 
> - 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。

```{python}
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        cover = 0
        if len(nums) == 1: return True
        i = 0
        # python不支持动态修改for循环中变量,使用while循环代替
        while i <= cover: # 只要当前位置 i 还在我能覆盖的范围内，我就可以站在 i 上继续跳
            cover = max(i + nums[i], cover) # 我走到当前位置 i 后，我的最远可达范围能不能被扩展
            if cover >= len(nums) - 1: return True
            i += 1 # 模拟向右移动，去检查下一个位置是否还能继续扩展 cover
        return False
```