---
title: "算法训练营Day 28"
author: "Siru Wu"
date: today
format: 
  html:
    embed-resources: true
---

## [122.买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

> 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
> 
> 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。然而，你可以在 同一天 多次买卖该股票，但要确保你持有的股票不超过一股。
> 
> 返回 你能获得的 最大 利润 。
>
> ![](/image/122example.png){width=50%}

```{python}
# 局部最优：收集每天的正利润
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        result = 0
        for i in range(1, len(prices)):
            result += max(prices[i] - prices[i - 1], 0) # 如果是负利润，那么max(negative,0)就是0，相当于跳过负利润，只收集正利润
        return result
```

## [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/description/)

> 给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。
> 
> 判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。
>
> **示例 1：**
> 
> - 输入：nums = [2,3,1,1,4]
> 
> - 输出：true
> 
> - 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
> 
> **示例 2：**
> 
> - 输入：nums = [3,2,1,0,4]
> 
> - 输出：false
> 
> - 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。

```{python}
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        cover = 0
        if len(nums) == 1: return True
        i = 0
        # python不支持动态修改for循环中变量,使用while循环代替
        while i <= cover: # 只要当前位置 i 还在我能覆盖的范围内，我就可以站在 i 上继续跳
            cover = max(i + nums[i], cover) # 我走到当前位置 i 后，我的最远可达范围能不能被扩展
            if cover >= len(nums) - 1: return True
            i += 1 # 模拟向右移动，去检查下一个位置是否还能继续扩展 cover
        return False
```

## [45.跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/description/)

> 给定一个长度为 n 的 0 索引整数数组 nums。初始位置在下标 0。
> 
> 每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在索引 i 处，你可以跳转到任意 (i + j) 处：
> 
> 0 <= j <= nums[i] 且 i + j < n
> 
> 返回到达 n - 1 的最小跳跃次数。测试用例保证可以到达 n - 1。

```{python}
class Solution:
    def jump(self, nums: List[int]) -> int:
        cover = 0
        result = 0
        if len(nums) == 1:
            return 0
        i = 0

        while i <= cover:
            for i in range(i, cover + 1): # 最小跳数的贪心是“扫完当前这一跳能到的区间”就步数 +1，而不是扫完整个数组,，所有右边的range是cover + 1而不是len(nums)
                cover = max(nums[i] + i, cover)
                if cover >= len(nums) - 1: # 在当前这一步里，我已经发现：下一步一定可以直接跳到终点，所以直接返回 count + 1
                    return result + 1
            result += 1
```

## [1005.K次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/)

> 给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：
> 
> - 选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。
> 
> 重复这个过程恰好 k 次。可以多次选择同一个下标 i 。
> 
> 以这种方式修改数组后，返回数组 可能的最大和 。
>
> **示例 1：**
> 
> - 输入：nums = [4,2,3], k = 1
> 
> - 输出：5
> 
> - 解释：选择下标 1 ，nums 变为 [4,-2,3] 。
> 
> **示例 2：**
> 
> - 输入：nums = [3,-1,0,2], k = 3
> 
> - 输出：6
> 
> - 解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。
> 
> **示例 3：**
> 
> - 输入：nums = [2,-3,-1,5,-4], k = 2
> 
> - 输出：13
> 
> - 解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。

```{python}
class Solution:
    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:
        A.sort(key=lambda x: abs(x), reverse=True)  # 第一步：按照绝对值降序排序数组A

        for i in range(len(A)):  # 第二步：执行K次取反操作
            if A[i] < 0 and K > 0:
                A[i] *= -1
                K -= 1

        if K % 2 == 1:  # 第三步：如果K还有剩余次数，将绝对值最小的元素取反
            A[-1] *= -1

        result = sum(A)  # 第四步：计算数组A的元素和
        return result
```