---
title: "算法训练营Day 29"
author: "Siru Wu"
date: today
format: 
  html:
    embed-resources: true
---

## [134. 加油站](https://leetcode.cn/problems/gas-station/description/)

> 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
> 
> 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
> 
> 给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。
>
> ![](/image/134example.png){width=50%}
>
> ![](/image/134example2.png){width=50%}

### 暴力法（会超时）

这里是index = (i + 1) % len(cost) 模拟 环形前进 的实例解释：

![](/image/134circle_explanation.png){width = 60%}

```{python}
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        for i in range(len(cost)):
            rest = gas[i] - cost[i]  # 记录剩余油量
            index = (i + 1) % len(cost)  # 下一个加油站的索引

            while rest > 0 and index != i:  # 模拟以i为起点行驶一圈, 如果index == i, 说明车又回到了起点 i，已经跑了一整圈，可以停了
                rest += gas[index] - cost[index]  # 更新剩余油量
                index = (index + 1) % len(cost)  # 更新下一个加油站的索引

            if rest >= 0 and index == i:  # 如果以i为起点跑一圈，剩余油量>=0，并且回到起始位置
                return i  # 返回起始位置i

        return -1  # 所有起始位置都无法环绕一圈，返回-1
```

### 贪心算法

```{python}
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        curSum = 0  # 当前累计的剩余油量
        totalSum = 0  # 总剩余油量
        start = 0  # 起始位置
        
        for i in range(len(gas)):
            curSum += gas[i] - cost[i]
            totalSum += gas[i] - cost[i]
            
            if curSum < 0:  # 当前累计剩余油量curSum小于0
                start = i + 1  # 起始位置更新为i+1
                curSum = 0  # curSum重新从0开始累计
        
        if totalSum < 0:
            return -1  # 总剩余油量totalSum小于0，说明无法环绕一圈
        return start
```

## [135. 分发糖果](https://leetcode.cn/problems/candy/description/)

> n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。
> 
> 你需要按照以下要求，给这些孩子分发糖果：
> 
> - 每个孩子至少分配到 1 个糖果。
> 
> - 相邻两个孩子中，评分更高的那个会获得更多的糖果。
> 
> 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。
>
> **示例 1：**
> 
> - 输入：ratings = [1,0,2]
> 
> - 输出：5
> 
> - 解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
> 
> **示例 2：**
> 
> - 输入：ratings = [1,2,2]
> 
> - 输出：4
> 
> - 解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
> 
> - 第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。

```{python}
class Solution:
    def candy(self, ratings: List[int]) -> int:
        n = len(ratings)
        candies = [1] * n
        
        # Forward pass: handle cases where right rating is higher than left
        for i in range(1, n):
            if ratings[i] > ratings[i - 1]:
                candies[i] = candies[i - 1] + 1
        
        # Backward pass: handle cases where left rating is higher than right
        for i in range(n - 2, -1, -1):
            if ratings[i] > ratings[i + 1]:
                candies[i] = max(candies[i], candies[i + 1] + 1)
        
        return sum(candies)
```

## [860.柠檬水找零](https://leetcode.cn/problems/lemonade-change/description/)

> 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。
> 
> 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。
> 
> 注意，一开始你手头没有任何零钱。
> 
> 给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。
>
> ![](/image/860example.png){width=50%}

```{python}
class Solution:
    def lemonadeChange(self, bills: List[int]) -> bool:
        five = 0
        ten = 0
        twenty = 0
        
        for bill in bills:
            # 情况一：收到5美元
            if bill == 5:
                five += 1
            
            # 情况二：收到10美元
            if bill == 10:
                if five <= 0:
                    return False
                ten += 1
                five -= 1
            
            # 情况三：收到20美元
            if bill == 20:
                # 先尝试使用10美元和5美元找零
                if five > 0 and ten > 0:
                    five -= 1
                    ten -= 1
                    #twenty += 1
                # 如果无法使用10美元找零，则尝试使用三张5美元找零
                elif five >= 3:
                    five -= 3
                    #twenty += 1
                else:
                    return False
        
        return True
```

## [406.根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/description/)

> 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
> 
> 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。
>
> ![](/image/406example.png){width=50%}

inser(p[1], p) example:
![](/image/406insert_example.png){width=70%}

```{python}
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
    	# 先按照h维度的身高顺序从高到低排序。确定第一个维度
        # lambda返回的是一个元组：当-x[0](维度h）相同时，再根据x[1]（维度k）从小到大排序
        people.sort(key=lambda x: (-x[0], x[1]))
        que = []
	
	# 根据每个元素的第二个维度k，贪心算法，进行插入
        # people已经排序过了：同一高度时k值小的排前面。
        for p in people:
            que.insert(p[1], p)
        return que
```