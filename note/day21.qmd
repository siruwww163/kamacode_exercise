---
title: "算法训练营Day 21"
author: "Siru Wu"
date: today
format: 
  html:
    embed-resources: true
---

## [669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/description/)

> 给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。
> 
> 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。
>
> ![](/image/669example.png){width=50%}

**对每个节点:**

**- 小于 low，整棵左子树都不要**

**- 大于 high，整棵右子树都不要**

**- 在区间内，就递归修剪左右子树并接回来**

```{python}
# trimBST(root):
#   if root 不存在: return None
#   if root 太小: 返回修剪后的右子树
#   if root 太大: 返回修剪后的左子树
#   否则:
#     修剪左子树
#     修剪右子树
#     返回 root
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def trimBST(self, root: Optional[TreeNode], low: int, high: int) -> Optional[TreeNode]:
        if root is None:
            return None
        if root.val < low: # root的值大于low，可以抛弃整个左子树
            # 寻找符合区间 [low, high] 的节点
            return self.trimBST(root.right, low, high)
        if root.val > high: # root的值小于low，可以抛弃整个右子树
            # 寻找符合区间 [low, high] 的节点
            return self.trimBST(root.left, low, high)
        root.left = self.trimBST(root.left, low, high)  # root.left 接入符合条件的左孩子
        root.right = self.trimBST(root.right, low, high)  # root.right 接入符合条件的右孩子
        return root
```

## [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/)

> 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。
>
> ![](/image/108example1.png){width=50%}
>
> ![](/image/108example2.png){width=50%}

### 递归法

```{python}
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def traversal(self, nums: List[int], left: int, right: int) -> TreeNode:
        if left > right: # 这里的left, right, mid都是nums的index，而不是val
            return None
        
        mid = left + (right-left) // 2
        root = TreeNode(nums[mid])
        root.left = self.traversal(nums, left, mid - 1)
        root.right = self.traversal(nums, mid + 1, right)
        return root

    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
         root = self.traversal(nums, 0, len(nums) - 1)
         return root

```

## [538.把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/description/)

> 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。
> 
> 提醒一下，二叉搜索树满足下列约束条件：
> 
> - 节点的左子树仅包含键 小于 节点键的节点。
> 
> - 节点的右子树仅包含键 大于 节点键的节点。
> 
> - 左右子树也必须是二叉搜索树。
> 
> 注意：本题和 1038: https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/ 相同
>
> ![](/image/538example1.png){width=50%}
>
> ![](/image/538example2.png){width=50%}

```{python}


# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        self.pre = 0
        self.traversal(root)
        return root

    def traversal(self, cur):
        if not cur:
            return
        self.traversal(cur.right)
        cur.val += self.pre # 题目要求改的是当前节点的值，不是 pre 本身
        # 当前节点已经变成「累加后的值」，它要作为「更小节点」的累加基础
        self.pre = cur.val # 所以 pre 必须更新成 当前的新值
        self.traversal(cur.left) 
```