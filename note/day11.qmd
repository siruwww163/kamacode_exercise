---
title: "算法训练营Day 11"
author: "Siru Wu"
date: today
format: 
  html:
    embed-resources: true
---

逆波兰式是一种表达式书写方式，运算符写在操作数后面，它也被称为 后缀表达式（Postfix Expression）。

![](/image/150RPN.png){width = 50%}

逆波兰式的计算规则：

![](/image/150rpn_cal.png){width= 50%}

## [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/)

> 给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。
> 
> 请你计算该表达式。返回一个表示表达式值的整数。
> 
> 注意：
> 
> - 有效的算符为 '+'、'-'、'*' 和 '/' 。
> 
> - 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
> 
> - 两个整数之间的除法总是 向零截断 。
> 
> - 表达式中不含除零运算。
> 
> - 输入是一个根据逆波兰表示法表示的算术表达式。
> 
> - 答案及所有中间计算结果可以用 32 位 整数表示。
>
> ![](/image/150example.png){width = 50%}

```{python}
from operator import add, sub, mul

# / 会产生浮点数，不适合整数除法
# // 是整数运算，但对负数是向下取整
# 所以负数除法要用 abs(x)//abs(y) 再手动加符号
def div(x, y):
    return int(x / y) if x * y > 0 else -(abs(x) // abs(y))

class Solution(object):
    op_map = {'+': add, '-': sub, '*': mul, '/': div} # 这里的div就是上面我们自己定义的def div

    def evalRPN(self, tokens):
        stack = []

        for token in tokens:
            if token in self.op_map:
                op2 = stack.pop()
                op1 = stack.pop()
                stack.append(self.op_map[token](op1, op2))
            else:
                stack.append(int(token)) # 这里要写成int(token), 
        return stack.pop()

```

## [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/description/)

> 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
> 
> 返回 滑动窗口中的最大值 。
>
> ![](/image/239example.png)

### 使用自定义的单调队列类

```{python}
from collections import deque


class MyQueue: #单调队列（从大到小
    def __init__(self):
        self.queue = deque() #这里需要使用deque实现单调队列，直接使用list会超时
    
    #每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。
    #同时pop之前判断队列当前是否为空。
    def pop(self, value):
        if self.queue and value == self.queue[0]:
            self.queue.popleft()#list.pop()时间复杂度为O(n),这里需要使用collections.deque()
            
    #如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。
    #这样就保持了队列里的数值是单调从大到小的了。
    def push(self, value):
        while self.queue and value > self.queue[-1]:
            self.queue.pop()
        self.queue.append(value)
        
    #查询当前队列里的最大值 直接返回队列前端也就是front就可以了。
    def front(self):
        return self.queue[0]
    
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        que = MyQueue()
        result = []
        for i in range(k): #先将前k的元素放进队列
            que.push(nums[i])
        result.append(que.front()) #result 记录前k的元素的最大值
        for i in range(k, len(nums)):
            que.pop(nums[i - k]) #滑动窗口移除最前面元素
            que.push(nums[i]) #滑动窗口前加入最后面的元素
            result.append(que.front()) #记录对应的最大值
        return result
```

### 直接用单调队列

```{python}
from collections import deque
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        max_list = []
        # kept_nums的取值是 下一个数更大的话，直接pop清空 前面的数字，如果下一个数没有当前数字大的话就append，这就保证kept_nums[-1]一定是当前窗口最大值
        kept_nums = deque()

        for i in range(len(nums)):
            update_kept_nums(kept_nums, nums[i]) # 右侧新元素加入

            # 当 i > k的时候，说明当前窗口长度超过了k值（实际的窗口长度），所以我们需要把最左边的那个值删掉
            # 虽然在我们眼里滑动窗口向右移动左边的值就不在窗口范围内了，但是在代码中我们要写这个if来告诉计算机我们挪动了，不需要超出范围的值了
            if i >= k and kept_nums[0] == nums[i - k]: 
                kept_nums.popleft() # 删除超过窗口的最左边的值
                # 例如k = 3, 然后我们加入了第4个数，那么当前kept_nums[0]这个数 == nums[i - k]的话就删掉它

            if i >= k - 1: #当 
                # 加入 k = 3, 那么当i = 3的时候第一个窗口就形成了，从 i = 2 (也就是 k - 1)开始往后滑动的每一个窗口我们都要记录max并且append
                max_list.append(kept_nums[0])

        return max_list

def update_kept_nums(kept_nums, num): # num 是新加入的元素
    while kept_nums and num > kept_nums[-1]: # 当kept_nums存在，并且新加入的数字大于当前kept_nums的最大值的时候，直接pop 清空 当前kept_nums的所有内容，然后把新的数字加入kept_nums
        kept_nums.pop()

    kept_nums.append(num)
```

## [347 前k个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/description/)

> 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。
> 
> **示例 1：**
> 
> 输入：nums = [1,1,1,2,2,3], k = 2    输出：[1,2]
> 
> **示例 2：**
> 
> 输入：nums = [1], k = 1     输出：[1]
> 
> **示例 3：**
> 
> 输入：nums = [1,2,1,2,1,2,3,1,3,2], k = 2   输出：[1,2]


### 小顶堆（min heap）和 大顶堆（max heap）

> **小顶堆（min heap）**
> 
> - 堆顶元素是最小的
> 
> - 每个父节点 ≤ 它的左右子节点
> 
> - 最小值永远在最上面

> **大顶堆（max heap）**
> 
> - 堆顶元素是最大的
> 
> - 每个父节点 ≥ 它的左右子节点
> 
> - 最大值永远在最上面

![](/image/347hasppush.png){width=90%}

### Counter

```{python}
import heapq
from collections import Counter

class Solution:
    def topKFrequent(self, nums, k):
        # 1. 统计每个数字出现的次数
        count = Counter(nums)

        # 2. 用小顶堆，堆里放 (频率, 数字)
        # Python 的 heapq 是 按第一个元素排序, 我们要比的是 频率, 所以频率必须放前面
        heap = []

        for num, freq in count.items():
            heapq.heappush(heap, (freq, num))
            # 如果堆大小超过 k，就弹出频率最小的
            if len(heap) > k:
                heapq.heappop(heap)

        # 3. 从堆中取结果
        return [num for freq, num in heap]

```

### 解法二

```{python}
#时间复杂度：O(nlogk)
#空间复杂度：O(n)
import heapq
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        #要统计元素出现频率
        map_ = {} #nums[i]:对应出现的次数
        for i in range(len(nums)):
            map_[nums[i]] = map_.get(nums[i], 0) + 1
        
        #对频率排序
        #定义一个小顶堆，大小为k
        pri_que = [] #小顶堆
        
        #用固定大小为k的小顶堆，扫描所有频率的数值
        for key, freq in map_.items():
            heapq.heappush(pri_que, (freq, key))
            if len(pri_que) > k: #如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k
                heapq.heappop(pri_que)
        
        #找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组
        result = [0] * k
        for i in range(k-1, -1, -1):
            result[i] = heapq.heappop(pri_que)[1]
        return result
```