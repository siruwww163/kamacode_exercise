---
title: "算法训练营Day 7"
author: "Siru Wu"
date: today
format: 
  html:
    embed-resources: true
---

## [454 四数相加](https://leetcode.cn/problems/4sum-ii/description/)

> 给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：
>
> - 0 <= i, j, k, l < n
>
> - nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
> 
> **示例 1：**
> 
> - 输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
> 
> - 输出：2
>
> 解释：两个元组如下：
> 
> - 1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
> 
> - 2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
> 
> **示例 2：**
> 
> - 输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
> 
> - 输出：1

本题解题步骤：

- 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。
  
- 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。

- 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。

- 再遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。

- 最后返回统计值 count 就可以了

```{python}
class Solution(object):
    def fourSumCount(self, nums1, nums2, nums3, nums4):
      result = dict()
      for n1 in nums1:
        for n2 in nums2:
          if n1 + n2 in result:
            result[n1 + n2] += 1
          else:
            result[n1 + n2] = 1

      count = 0
      for n3 in nums3:
        for n4 in nums4:
          key = - n3 - n4
          if key in result:
            # 这里不是在找能不能配对，而是在找有多少对配对的
            count += result[key] # 这里不能用 count += 1因为题目没保证 有distinct的一对 n1 + n2
      return count
```

## [383 赎金信](https://leetcode.cn/problems/ransom-note/description/)

> 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。
> 
> 如果可以，返回 true ；否则返回 false 。
> 
> magazine 中的每个字符只能在 ransomNote 中使用一次。
>
> /![](/image/383.png){width=60%}

### 使用数组

```{python}
class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
      ransom_count = [0] * 26
      magazine_count = [0] * 26
      for j in ransomNote:
        ransom_count[ord(j) - ord('a')] += 1
      for j in magazine:
        magazine_count[ord(j) - ord('a')] += 1

      return all(ransom_count[i] <= magazine_count[i] for i in range(26)) # ransom里面这个字母用到的次数小于magazinez， ransomNote 才能由 magazine 里面的字符构成
      # all() 返回bool值， 只要有一个是 False → 整体 False，全部是 True → 整体 True
```

### 使用Counter

```{python}
from collections import Counter

class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
      # 如果还有剩余需求：
      # not (...)
      # Counter(...) != {}
      # not Counter(...) == False

      # 如果完全抵消：
      # Counter(...) == {}
      # not Counter(...) == True
      return not Counter(ransomNote) - Counter(magazine)
```

### 使用字典

```{python}
class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:

      # 建立库存表
      count = {}
      # counts[c] 表示字母 c 在 magazine 里还剩多少个
      for c in magazine:
        count[c] = count.get(c, 0) + 1 # get(c, 0) 保证第一次出现不会 KeyError

      # 用 ransomNote 消耗库存
      for c in ransomNote:
        # 两种失败情况
        # c not in count：magazine 里从来没有这个字母
        # count[c] = 0： 有这个字母，但已经被用光了
        if c not in count or count[c] == 0:
          return False
        count[c] -= 1 # 消耗一个字符
      return True
```

## [15 三数之和](https://leetcode.cn/problems/3sum/description/)

> 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。
> 
> 注意：答案中不可以包含重复的三元组。
>
> ![](/image/15.png){width=60%}

```{python}
class Solution:
  def threeSum(self, nums: List[int]) -> List[List[int]]:
    result = []
    nums.sort() 
    
    # 固定 nums[i],  i 右侧用 left / right 找两数之和
    for i in range(len(nums)):
      if nums[i] > 0: # 剪枝优化，nums[i] > 0 直接结束
        return result

      if i > 0 and nums[i - 1] == nums[i]: # 外层去重：避免相同的第一个数，外层去重只能防住 i 重复，完全防不住 i 后面 left / right 产生的重复组合。
        continue
      
      # 双指针搜索区间是，(i, right]
      left = i + 1
      right = len(nums) - 1 

      while right > left: # 只要左右指针没相遇，就一直找。
        sum_3 = nums[i] + nums[left] + nums[right]
        if sum_3 < 0:
          left += 1 # sum_ < 0 → left 右移
        elif sum_3 > 0:
          right -= 1 # sum_ > 0 → right 左移
        else:
          result.append([nums[i], nums[left], nums[right]]) # sum_ == 0 → 找到答案

          # 这里的while要写在else里面，因为以下所有的去重 / 挪动双指针的操作都是基于我们已经找到第一个三数之和为0的情况下

          # 内层去重：跳过重复的 left 和 right
          # 例子：[-1, 0, 0, 0, 1]，如果不跳过，(0, 0, 1) 会被加入很多次
          while right > left and nums[right] == nums[right - 1]:
            right -= 1
          while right > left and nums[left] == nums[left + 1]:
            left += 1

          # 双指针继续移动
          # 当前组合已经用过, 继续找下一个可能的组合
          right -= 1
          left += 1

    return result
```



## [18 四数之和](https://leetcode.cn/problems/4sum/description/)

> 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：
> 
> 0 <= a, b, c, d < n
> 
> a、b、c 和 d 互不相同
> 
> nums[a] + nums[b] + nums[c] + nums[d] == target
> 
> 你可以按 任意顺序 返回答案 。
>
> ![](/image/18.png){width=60%}

```{python}
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        # 先对数组排序
        # 排序的目的：
        # 1. 方便使用双指针
        # 2. 方便后面做剪枝
        # 3. 方便对结果进行去重
        nums.sort()

        n = len(nums)
        result = []  # 用来存放最终所有不重复的四元组结果

        # 第一层循环：固定第一个数 nums[i]
        for i in range(n):

            # 剪枝（可省）
            # 当前 nums[i] 已经是正数
            # target 也是正数
            # 并且 nums[i] 已经大于 target
            # 由于数组已经排序，后面的数只会更大
            # 四个正数相加一定 > target
            # 所以后面不可能再有解，直接结束循环
            if nums[i] > target and nums[i] > 0 and target > 0:
                break

            # 去重 i
            # 如果当前 nums[i] 和上一个 nums[i-1] 一样
            # 说明以这个数为第一个数的所有组合已经算过了
            # 直接跳过，避免产生重复结果
            if i > 0 and nums[i] == nums[i - 1]:
                continue

            # 第二层循环：固定第二个数 nums[j]
            for j in range(i + 1, n):

                # 剪枝（可省）
                # 如果 nums[i] + nums[j] 已经大于 target
                # 并且 target 是正数
                # 后面两个数只会更大，不可能再凑出 target
                if nums[i] + nums[j] > target and target > 0:
                    break

                # 去重 j
                # j > i + 1 保证是同一层中出现的重复
                # 避免出现相同的第二个数导致重复结果
                if j > i + 1 and nums[j] == nums[j - 1]:
                    continue

                # 使用双指针查找剩下的两个数
                # left 从 j 的右边开始
                # right 从数组末尾开始
                left, right = j + 1, n - 1

                # 当左右指针没有相遇时，不断查找
                while left < right:
                    # 当前四个数的和
                    s = nums[i] + nums[j] + nums[left] + nums[right]

                    # 情况 1：刚好等于 target，找到一个合法解
                    if s == target:
                        result.append([nums[i], nums[j], nums[left], nums[right]])

                        # 去重 left
                        # 如果下一个 left 的值和当前一样
                        # 会产生重复的四元组，必须跳过
                        while left < right and nums[left] == nums[left + 1]:
                            left += 1

                        # 去重 right
                        # 同理，跳过重复的右指针值
                        while left < right and nums[right] == nums[right - 1]:
                            right -= 1

                        # 当前组合已经处理完
                        # 同时移动左右指针，继续寻找下一个可能组合
                        left += 1
                        right -= 1

                    # 情况 2：当前和小于 target
                    # 由于数组有序，想让和变大，只能移动 left
                    elif s < target:
                        left += 1

                    # 情况 3：当前和大于 target
                    # 想让和变小，只能移动 right
                    else:
                        right -= 1

        # 返回所有不重复的四元组结果
        return result

```