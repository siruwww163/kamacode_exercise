---
title: "算法训练营Day 2"
author: "Siru Wu"
date: today
format: 
  html:
    embed-resources: true
---

今天是算法训练营的第二天。激动！

## [209 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)

> 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。
> 
> 示例：
> 
> - 输入：s = 7, nums = [2,3,1,2,4,3]
> - 输出：2
> - 解释：子数组 [4,3] 是该条件下的长度最小的子数组。
> - 提示：
> - 1 <= target <= 10^9
> - 1 <= nums.length <= 10^5
> - 1 <= nums[i] <= 10^5

在看视频讲解之前只想到了暴力解法（甚至还是双指针版本的但是做出来效果跟暴力解法一模一样的那种。。。），看了视频讲解才发现原来还有固定终止位置，然后移动起始位置，不断地缩小起始位置和终止位置的区间来判断是否有更小的区间能满足题目的要求。for 循环里面的j表示的是终止位置。

滑动窗口 - 双指针法
```{python}
class Solution:
    def minSubArrayLen(self, target:int, nums:List[int]) -> int:
        len_nums = len(nums)
        left = 0
        right = 0
        # 这里不能用min_len = 0代替，这样的话min_len的值就被固定成了0，不管再短的子数组长度都不会短于0
        min_len = float('inf') # 这里用∞作为初始值，表示“还没找到任何合法子数组”。
        cum_sum = 0

        while right < len_nums: # 这里也可以写成 for right in range(len_nums) 或者right <= len_nums-1
            cum_sum += nums[right]

            while cum_sum >= target:
                min_len = min(min_len, right - left + 1)
                cum_sum -= nums[left]
                left += 1
            
            right += 1
        return min_len if min_len != float('inf') else 0
```

暴力法
```{python}
class Solution:
    def minSubArrayLen(self, target:int, nums:List[int]) -> int:
        len_num = len(nums)
        min_len = float('inf')

        for i in range(len_num):
            cum_sum = 0
            for j in range(i, len_num): # 这里的j是从i开始的，不是1
                cum_sum += nums[j]
                if cum_sum >= target:
                    min_len = min(min_len, j-i+1)
                    break
         return min_len if min_len != float('inf') else 0
```

## [59.螺旋矩阵II](https://leetcode.cn/problems/spiral-matrix-ii/description/)

> 给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。
> 
> 示例: 输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]

```{python}
# 这道题的思路就是先创一个全部为0的matrix，然后创建x,y轴的起始点，确定loop和中心点。然后开始建四条边，再填充。最后填充中心点matrix[mid][mid]。
class Solution(object):
    def generateMatrix(self, n):
        """
        :type n: int
        :rtype: List[List[int]]
        """
        matrix = [[0] * n for _ in range(n)] # 创建一个全部值为0的matrix
        layer_count = n//2
        num = 1

        # 创建四条边
        for layer in range(layer_count):
            top = layer
            bottom = n - 1 - layer
            left = layer
            right = n - 1 - layer

            # 填充上边，matrix[top][j]
            for j in range(left, right): # 这里不能用range(n), 不然的话填到内圈的时候会重复填外圈的东西
                matrix[top][j] = num
                num += 1

            # 填充右边 matrix[i][right]
            for i in range(top, bottom):
                matrix[i][right] = num
                num += 1

            # 填充下边 matrix[bottom][j]
            for j in range(right, left, -1):
                matrix[bottom][j] = num
                num += 1

            # 填充左边 matrix[i][left]
            for i in range(bottom, top, -1):
                matrix[i][left] = num
                num += 1

        # 如果n是基数，那么这个matrix是有一个中心点matrix[mid][mid]， 值为n*n，也就是累计的num
        if n % 2 == 1:
            mid = n // 2
            matrix[mid][mid] = num # 这里也可以写成n*n

        return matrix
```

## [58 区间和](https://kamacoder.com/problempage.php?pid=1070)

```{python}
import sys # sys用来读不知道长度的输入
input = sys.stdin.read

def main():
    data = input().split()
    index = 0
    n = int(data[index]) # 此时n读的是data[0]的那个数字，也就是整个 数组 vec 的长度
    index += 1 # 这里我们已经得到n的值了，所以把index挪到list的第一个数字上用来创list

    vec = [] 
    for i in range(n):
        # 这里 vec.append 必须要把 字符串 转化成 int
        vec.append(int(data[index + i])) # 这里是创建整个list，只是把数字填进去
    index += n # 这里我们已经创好了list，所以把index挪到第一个区间上准备求区间和

    p = [0] * n # 创建一个全部值为0的list
    presum = 0
    # 这里我们要直接把range(n)的sum算出来，就可以用p[b] - p[a - 1]来算区间和，而不是每次新给一个区间就全部重头开始算
    for i in range(n):
        presum += vec[i]
        p[i] = presum # 每求出来一个presum就直接填进p list
    
    results = []
    while index < len(data):
        a = int(data[index]) # 记得这里要转化成int，不然a是字符串
        b = int(data[index + 1]) 
        index += 2 # 这里我们读data的时候是把所有的input都放进一行，不管是n还算是list还是区间，所以我们要自己定义哪一段到哪一段是什么，这里区间是两个数字所以 index +=2

        if a == 0: # 这里要用 a == 0, 
            # 在python里面 “=” 是赋值, a=0 意思是给a赋值0, a == 0 是判断a是否为0, 返回 True / False
            sum_value = p[b]
        else:
            sum_value = p[b] - p[a - 1] # 举例：区间[2, 5]的sum 等于p[5] - p[1]

        results.append(sum_value)

    for result in results:
        print(result)

if __name__ == "__main__": # 这里也要用 ==， 而不是 =
    main()
```

