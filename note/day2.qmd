---
title: "算法训练营Day 2"
author: "Siru Wu"
date: today
format: 
  html:
    embed-resources: true
---

今天是算法训练营的第二天。激动！

## [209 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)

> 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。
> 
> 示例：
> 
> - 输入：s = 7, nums = [2,3,1,2,4,3]
> - 输出：2
> - 解释：子数组 [4,3] 是该条件下的长度最小的子数组。
> - 提示：
> - 1 <= target <= 10^9
> - 1 <= nums.length <= 10^5
> - 1 <= nums[i] <= 10^5

在看视频讲解之前只想到了暴力解法（甚至还是双指针版本的但是做出来效果跟暴力解法一模一样的那种。。。），看了视频讲解才发现原来还有固定终止位置，然后移动起始位置，不断地缩小起始位置和终止位置的区间来判断是否有更小的区间能满足题目的要求。for 循环里面的j表示的是终止位置。

滑动窗口 - 双指针法
```{python}
class Solution:
    def minSubArrayLen(self, target:int, nums:List[int]) -> int:
        len_nums = len(nums)
        left = 0
        right = 0
        # 这里不能用min_len = 0代替，这样的话min_len的值就被固定成了0，不管再短的子数组长度都不会短于0
        min_len = float('inf') # 这里用∞作为初始值，表示“还没找到任何合法子数组”。
        cum_sum = 0

        while right < len_nums: # 这里也可以写成 for right in range(len_nums) 或者right <= len_nums-1
            cum_sum += nums[right]

            while cum_sum >= target:
                min_len = min(min_len, right - left + 1)
                cum_sum -= nums[left]
                left += 1
            
            right += 1
        return min_len if min_len != float('inf') else 0
```

暴力法
```{python}
class Solution:
    def minSubArrayLen(self, target:int, nums:List[int]) -> int:
        len_num = len(nums)
        min_len = float('inf')

        for i in range(len_num):
            cum_sum = 0
            for j in range(i, len_num): # 这里的j是从i开始的，不是1
                cum_sum += nums[j]
                if cum_sum >= target:
                    min_len = min(min_len, j-i+1)
                    break
         return min_len if min_len != float('inf') else 0
```

## [59.螺旋矩阵II](https://leetcode.cn/problems/spiral-matrix-ii/description/)

> 给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。
> 
> 示例: 输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]

```{python}
# 这道题的思路就是先创一个全部为0的matrix，然后创建x,y轴的起始点，确定loop和中心点。然后开始建四条边，再填充。最后填充中心点matrix[mid][mid]。
class Solution(object):
    def generateMatrix(self, n):
        """
        :type n: int
        :rtype: List[List[int]]
        """
        matrix = [[0] * n for _ in range(n)] # 创建一个全部值为0的matrix
        layer_count = n//2
        num = 1

        # 创建四条边
        for layer in range(layer_count):
            top = layer
            bottom = n - 1 - layer
            left = layer
            right = n - 1 - layer

            # 填充上边，matrix[top][j]
            for j in range(left, right): # 这里不能用range(n), 不然的话填到内圈的时候会重复填外圈的东西
                matrix[top][j] = num
                num += 1

            # 填充右边 matrix[i][right]
            for i in range(top, bottom):
                matrix[i][right] = num
                num += 1

            # 填充下边 matrix[bottom][j]
            for j in range(right, left, -1):
                matrix[bottom][j] = num
                num += 1

            # 填充左边 matrix[i][left]
            for i in range(bottom, top, -1):
                matrix[i][left] = num
                num += 1

        # 如果n是基数，那么这个matrix是有一个中心点matrix[mid][mid]， 值为n*n，也就是累计的num
        if n % 2 == 1:
            mid = n // 2
            matrix[mid][mid] = num # 这里也可以写成n*n

        return matrix
```

## [58 区间和](https://kamacoder.com/problempage.php?pid=1070)

> ![](/image/interval_sum_question.png)
>
> ![](/image/interval_sum_example.png)

```{python}
import sys # sys用来读不知道长度的输入
input = sys.stdin.read

def main():
    data = input().split()
    index = 0
    n = int(data[index]) # 此时n读的是data[0]的那个数字，也就是整个 数组 vec 的长度
    index += 1 # 这里我们已经得到n的值了，所以把index挪到list的第一个数字上用来创list

    vec = [] 
    for i in range(n):
        # 这里 vec.append 必须要把 字符串 转化成 int
        vec.append(int(data[index + i])) # 这里是创建整个list，只是把数字填进去
    index += n # 这里我们已经创好了list，所以把index挪到第一个区间上准备求区间和

    p = [0] * n # 创建一个全部值为0的list
    presum = 0
    # 这里我们要直接把range(n)的sum算出来，就可以用p[b] - p[a - 1]来算区间和，而不是每次新给一个区间就全部重头开始算
    for i in range(n):
        presum += vec[i]
        p[i] = presum # 每求出来一个presum就直接填进p list
    
    results = []
    while index < len(data):
        a = int(data[index]) # 记得这里要转化成int，不然a是字符串
        b = int(data[index + 1]) 
        index += 2 # 这里我们读data的时候是把所有的input都放进一行，不管是n还算是list还是区间，所以我们要自己定义哪一段到哪一段是什么，这里区间是两个数字所以 index +=2

        if a == 0: # 这里要用 a == 0, 
            # 在python里面 “=” 是赋值, a=0 意思是给a赋值0, a == 0 是判断a是否为0, 返回 True / False
            sum_value = p[b]
        else:
            sum_value = p[b] - p[a - 1] # 举例：区间[2, 5]的sum 等于p[5] - p[1]

        results.append(sum_value)

    for result in results:
        print(result)

if __name__ == "__main__": # 这里也要用 ==， 而不是 =
    main()
```

## [44. 开发商购买土地](https://kamacoder.com/problempage.php?pid=1044)

> 在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。 
> 
> 现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。
> 
> 然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。 为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。 
> 
> 注意：区块不可再分。


### 暴力版本

```{python}
"""
思路说明：
1. 读入 n×m 的土地价值矩阵，同时统计总和 total
2. 计算每一行的和 horizontal[i]，每一列的和 vertical[j]
3. 横向切分：用 horizontal 的前缀和模拟在某一行后切一刀，
   计算上下两部分价值差，取最小值
4. 纵向切分：用 vertical 的前缀和模拟在某一列后切一刀，
   同样更新最小差值
5. 输出所有切分方案中的最小差
"""
import sys
input = sys.stdin.read

def main():
    data = input().split()

    # 读n和m的值
    idx = 0
    n = int(data[idx])
    idx += 1
    m = int(data[idx])
    idx += 1 # 记得这里读完 m 之后还要 idx += 1

    # 创建matrix
    sum = 0
    vec = []
    for i in range(n):
        row = []
        for j in range(m):
            num = int(data[idx])
            idx += 1
            row.append(num)
            sum += num
        vec.append(row)

    # 横向统计， horizontal是横向统计用 i 是因为切出来 i 行，然后计算每一行的horizontal sum
    horizontal = [0] * n
    for i in range(n):
        for j in range(m):
            horizontal[i] += vec[i][j] 
            # horizontal是一个list, 不能直接用 horizontal += vec[i][j]

    # 纵向统计， 
    vertical = [0] * m
    for j in range(m):
        for i in range(n):
            vertical[j] += vec[i][j]

    # 横向切分
    result = float('inf')
    horizontalcut = 0
    for i in range(n - 1): # 这个地方可以用 n 也可以用 n-1, 用 n - 1更严谨是因为一般不会切到最后一行
        horizontalcut += horizontal[i]
        result = min(result, abs(sum - 2 * horizontalcut))
    
    # 纵向切分
    verticalcut = 0
    for j in range(m - 1): # m - 1 同理，也可以用 m
        verticalcut += vertical[j]
        result = min(result, abs(sum - 2 * verticalcut))

    print(result)

if __name__ == "__main__":
    main()
```

### 优化暴力版本

```{python}
"""
这个版本的思路是：
在遍历矩阵计算每一行（或每一列）累计和的同时，
在行末 / 列末对应的合法切分位置直接计算两部分的差值，
避免在后面再单独遍历一次进行比较。
"""
import sys
input = sys.stdin.read

def main():
    data = input().split()
    idx = 0
    n = int(data[idx]); idx += 1
    m = int(data[idx]); idx += 1

    sum = 0
    vec = []
    for i in range(n):
        row = []
        for j in range(m):
            num = int(data[idx]); idx += 1
            row.append(num)
            sum += num
        vec.append(row)

    result = float('inf')

    count = 0

    # 行切分
    for i in range(n):
        for j in range(m):
            count += vec[i][j]
            if j == m - 1 and i < n-1: # 遍历到行末尾时候开始统计，意思是行切分的时候，用 j == m - 1 检查这一行是否到末尾了，如果到末尾了这时候就开始算 i 行和剩下行的差值
                result = min(result, abs(sum - 2 * count))

    count = 0
    # 列切分
    for j in range(m):
        for i in range(n):
            count += vec[i][j]
            if i == n - 1 and j < m - 1:
                result = min(result, abs(sum - 2 * count))

    print(result)

if __name__ == "__main__":
    main()
```
