---
title: "算法训练营Day 4"
author: "Siru Wu"
date: today
format: 
  html:
    embed-resources: true
---

## [24 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

> 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
>
> ![](/image/24-example1.png){width=50%}
> 
> - 示例1: 输入：head = [1,2,3,4] --> 输出：[2,1,4,3]
>
> - 示例2: 输入：head = [] --> 输出：[]
> 
> - 示例 3: 输入：head = [1] --> 输出：[1]

```{python}
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def swapPairs(self, head):
        """
        :type head: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
        dummy = ListNode(next = head)
        cur = dummy

        while cur.next and cur.next.next:
            temp = cur.next
            temp1 = cur.next.next

            # 交换之前 current -> 1 -> 2 -> 3
            # 执行完这一步之后是 current -> 2 -> 3; temp -> 1
            cur.next = cur.next.next
            # 此时 current.next 是 2，temp 是 1
            # current.next.next = temp的目的是让2指向1， 等于2.next = 1
            cur.next.next = temp
            # temp.next = temp1 这一步是把后面的链表接回去，1 -> 3 -> 4
            temp.next = temp1
            # current.next = 新的这一对的头
            # current 要挪到 下一个要交换的节点的前面，而不是交换的两个节点之一
            # 凡是“成对/成组操作链表”的题，current 都站在组前面，不进组
            cur = cur.next.next

        return dummy.next
```

## [19.删除链表的倒数第N个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

> 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
>
> ![](/image/19-example1.png){width=50%}
>
> - 示例1：输入：head = [1,2,3,4,5], n = 2 -> 输出：[1,2,3,5]
> 
> - 示例 2：输入：head = [1], n = 1 -> 输出：[]
> 
> - 示例 3：输入：head = [1,2], n = 1 -> 输出：[1]

```{python}
# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution(object):
    def removeNthFromEnd(self, head, n):
        """
        :type head: Optional[ListNode]
        :type n: int
        :rtype: Optional[ListNode]
        """
        dummy = ListNode(0, head)
        # 这里也可以写成dummy = ListNode(next = head)
        slow = fast = dummy

        for i in range(n+1): # 这个地方因为我们要找倒数第n个节点，如果我们让fast先走n布之后再同时移动slow和fast，当fast 到null的时候，slow也就到了倒数第n个节点。但是我们删除这个节点的时候必须要找到这个节点的上一个节点然后用next.next覆盖，所以这里我们要让fast实际走n+1步来让slow找到倒数第n个节点的上一个节点。
            fast = fast.next
            # 这里不能写成fast += 1, 这种写法只能用于数值，不能用于节点指针

        while fast: # 循环直到fast到空节点
            fast = fast.next
            slow = slow.next

        slow.next = slow.next.next
        return dummy.next
```


## [面试题 02.07 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/)

> 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。图示两个链表在节点 c1 开始相交：
>
> ![](/image/02-07-question.png)
>
> 题目数据 保证 整个链式结构中不存在环。
> 
> 注意，函数返回结果后，链表必须 **保持其原始结构** 。
>
> ![](/image/02-07-example1.png)
>
> ![](/image/02-07-example2.png)
>
> ![](/image/02-07-example3.png)

```{python}
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def getIntersectionNode(self, headA, headB):
        """
        :type head1, head1: ListNode
        :rtype: ListNode
        """
        # not headA 等价于 headA is None
        # 如果链表 A 是空的，或者链表 B 是空的，就直接返回 None
        if not headA or not headB:
            return None

        # pA 指向链表 A 的头节点
        # pB 指向链表 B 的头节点
        # 我们不直接用 headA、headB是因为我们需要在遍历过程中不断移动指针，如果直接用 headA = headA.next，会把原来的头指针弄乱
        # 所以要保留 headA、headB 不动，用 pA、pB 来“走链表”
        pA, pB = headA, headB

        # 这里考虑的是节点相同，而不是节点值相同。
        # 判断相交用的是：pA == pB。不是：pA.val == pB.val

        while pA != pB: # 当两个指针第一次走到那个共享节点时，pA == pB 成立，循环结束，返回这个节点

            pA = pA.next if pA else headB # 指针没走到头就继续往前走，走到头了就换一条链表，从另一条链表的头重新走。

            # 这一句等价于:
            # if pA is not None:
            #     pA = pA.next
            # else:
            #     pA = headB
            pB = pB.next if pB else headA # headB和pB不是一个情况，虽然我们前面检查了headA / headB是否为None, 但是pA / pB是我们后面自己又定义的，所以还是要检查是否为None。
        return pA
```

## [142 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/description/)

> 给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
> 
> 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
> 
> **不允许修改 链表。**
>
> ![](/image/142-example1.png)
>
> ![](/image/142-example2.png)
>
> ![](/image/142-example3.png)


```{python}
# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution(object):
    def detectCycle(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        slow = head
        fast = head

        # 用来判断是否有环
        while fast and fast.next: # 这一步需要保证：fast 不是 None，fast.next 也不是 None，否则会访问空指针报错。
            # 同时这也等价于：如果链表走到末尾（无环），fast 会先变成 None 或 fast.next 变成 None，循环结束。
            slow = slow.next # slow 走 1 步
            fast = fast.next.next # fast 走 2 步

            if slow == fast: # 相遇判断：发现有环
                # 把 slow 拉回 head，这一步是为了找 环的入口
                slow = head
                
                # 第二段 while: 同速前进，第一次相遇就是入口
                while slow != fast:
                    slow = slow.next
                    fast = fast.next
                return slow
        
        # 如果没环，return None
        return None
```