---
title: "算法训练营Day 4"
author: "Siru Wu"
date: today
format: 
  html:
    embed-resources: true
---

## [24 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

> 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
>
> ![](/image/24-example1.png){width=50%}
> 
> - 示例1: 输入：head = [1,2,3,4] --> 输出：[2,1,4,3]
>
> - 示例2: 输入：head = [] --> 输出：[]
> 
> - 示例 3: 输入：head = [1] --> 输出：[1]

```{python}
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def swapPairs(self, head):
        """
        :type head: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
        dummy = ListNode(next = head)
        cur = dummy

        while cur.next and cur.next.next:
            temp = cur.next
            temp1 = cur.next.next

            # 交换之前 current -> 1 -> 2 -> 3
            # 执行完这一步之后是 current -> 2 -> 3; temp -> 1
            cur.next = cur.next.next
            # 此时 current.next 是 2，temp 是 1
            # current.next.next = temp的目的是让2指向1， 等于2.next = 1
            cur.next.next = temp
            # temp.next = temp1 这一步是把后面的链表接回去，1 -> 3 -> 4
            temp.next = temp1
            # current.next = 新的这一对的头
            # current 要挪到 下一个要交换的节点的前面，而不是交换的两个节点之一
            # 凡是“成对/成组操作链表”的题，current 都站在组前面，不进组
            cur = cur.next.next

        return dummy.next
```

## [19.删除链表的倒数第N个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

> 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
>
> ![](/image/19-example1.png){width=50%}
>
> - 示例1：输入：head = [1,2,3,4,5], n = 2 -> 输出：[1,2,3,5]
> 
> - 示例 2：输入：head = [1], n = 1 -> 输出：[]
> 
> - 示例 3：输入：head = [1,2], n = 1 -> 输出：[1]

```{python}
# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution(object):
    def removeNthFromEnd(self, head, n):
        """
        :type head: Optional[ListNode]
        :type n: int
        :rtype: Optional[ListNode]
        """
        dummy = ListNode(0, head)
        # 这里也可以写成dummy = ListNode(next = head)
        slow = fast = dummy

        for i in range(n+1): # 这个地方因为我们要找倒数第n个节点，如果我们让fast先走n布之后再同时移动slow和fast，当fast 到null的时候，slow也就到了倒数第n个节点。但是我们删除这个节点的时候必须要找到这个节点的上一个节点然后用next.next覆盖，所以这里我们要让fast实际走n+1步来让slow找到倒数第n个节点的上一个节点。
            fast = fast.next
            # 这里不能写成fast += 1, 这种写法只能用于数值，不能用于节点指针

        while fast: # 循环直到fast到空节点
            fast = fast.next
            slow = slow.next

        slow.next = slow.next.next
        return dummy.next
```


## [面试题 02.07 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/)

> 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。图示两个链表在节点 c1 开始相交：
>
> ![](/image/02-07-question.png)
>
> 题目数据 保证 整个链式结构中不存在环。
> 
> 注意，函数返回结果后，链表必须 **保持其原始结构** 。
>
> ![](/image/02-07-example1.png)
>
> ![](/image/02-07-example2.png)
>
> ![](/image/02-07-example3.png)